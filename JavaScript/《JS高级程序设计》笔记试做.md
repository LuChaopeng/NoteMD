### 必知必会

#### 1、词汇

async（asynchronous） 异步

defer 延缓

binary  二进制

octal  八进制

hexadecimal  十六进制



## 第2章 HTML中的JavaScript

#### 2.1 `<script>`元素

1. 执行顺序：浏览器会按照`<script>`在页面中出现的顺序依次解释它们，前提是它们没有使用 defer （延缓）和 async（异步） 属性。

2. 把JavaScript引用放在`<body>`元素中的页面内容后面，避免先把所有 JavaScript 代码都下载、解析和解释完成。

3. 推迟执行JavaScript

   在<script>元素上设置 defer 属性，相当于告诉浏览器立即下载（但也是要到加载到这个元素），但延迟执行，延迟到整个页面都解析完毕后。

   **有多个延迟脚本defer时执行顺序不能确定（尽管大多按照先后顺序），因此最好只包含一个这样的脚本**

4. 异步执行

   可以使用 async 属性表示脚本不需要等待其他脚本，同时也不阻塞文档渲染，即异步加载。异步脚本不能保证按照它们在页面中出现的次序执行。正因为如此，异步脚本**不应该在加载期间修改 DOM**。

5. 动态加载脚本

   可以通过DOM操作向DOM中添加script元素以加载脚本。

6. XHTML本意代替HTML，现已退出历史舞台。

#### 2.2 行内代码与外部文件

1. 最佳实践

   尽可能将JavaScript代码放在外部文件中。

   **可维护性、缓存、适应未来**

#### 2.3文档模式

1. 标准模式下，浏览器按照规范呈现页面。混杂模式下，页面以一种比较宽松的向后兼容的方式显示。

   `<!DOCTYPE html>`是标准模式下HTML5的声明；

   混杂模式靠省略doctype开启；

   标准模式和准标准模式非常接近。

#### 2.4 `<noscript>`元素

1. 对禁用或不支持（已经没有不支持js的了）JavaScript的浏览器提供替代内容。如果浏览器支持并启用脚本，则`<noscript>`元素中的任何内容都不会被渲染。



## 第3章 语言基础

#### 3.1 `<script>`元素

1. ECMAScript中一切都区分大小写

2. ECMAScript标识符的最佳实践是**使用驼峰大小写形式**。

3. 严格模式

   要对整个脚本启用严格模式，在脚本开头加上这一行：

   ** `"use strict";` **

   也可在函数体开头单独指定一个函数严格模式。

4. 语句加分号；一条语句也用代码块；

#### 3.3 变量

1. 不推荐改变变量保存值的类型。

2. var的声明的作用域为包含它的**函数作用域**  **（*这里的函数指ECMAScript函数？定义在`if`语句中的大括号内的变量还在函数作用域内）**。

   去掉var 操作符之后，变量 就变成了全局变量，严格模式下不允许。

   用var定义变量会声明“提升”（hoist），也就是把所有变量声明都拉到函数作用域的顶部。

3. `let`和`var`声明的区别

   1. `let`是块作用域；`var`是函数作用域

   2. `let`声明的变量在作用域中不会被提升；

   3. `let`在*全局作用域中*声明的变量不会成为window对象的属性，`var`声明的会；

   4. for循环中，使用`var`定义的迭代变量会渗透到循环体外部。

      奇特问题：`eg`:

      ```javascript
      for (var i = 0; i < 5; ++i) { 
       setTimeout(() => console.log(i), 0) 
      } 
      // 你可能以为会输出 0、1、2、3、4 
      // 实际上会输出 5、5、5、5、5 
      /*
      因为在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时逻辑时，所有的 i 都是同一个变量.
      */
      
      for (let i = 0; i < 5; ++i) { 
       setTimeout(() => console.log(i), 0) 
      } 
      // 会输出 0、1、2、3、4
      /*
      而在使用 let 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量。
      */
      ```

4. `const`声明

   与`let`基本相同。

   区别：声明的**同时必须初始化变量**，且之后**不可被修改**。

   所以`const`不能声明迭代变量。

   但是值得注意的是，`const` 声明的限制只适用于它指向的变量的引用。如果 `const` 变量引用的是一个对象，可以修改这个对象内部的属性。

   因此可以在`for-of` 和` for-in` 循环中使用。

5. **最佳实践**

   `const`优先，`let`次之，不使用`var`。

#### 3.4 数据类型

1. ECMAScript不能自定数据类型，所有值使用7种数据类型表示

   **6种简单数据类型（原始类型）**

   Undefined、Null、Boolean、Number、String、Symbol

   **1种复杂数据类型**

   Object

2. `typeof`操作符

   ECMAScript类型松散，通过** `typeof`操作符**知道数据类型，其返回的字符串值有7种：

   - "undefined"  未定义；
   - "boolean"  布尔值；
   - "string"  字符串
   - "number"  数值
   - "object"  对象或null
   - "function"  函数
   - "symbol"  符号

   **注意：**

   `typeof`是一个操作符，不需要参数（可以使用参数）；

   `typeof null`返回"object"，`null`被认为是一个对空对象的引用；

   函数其实是对象，但其有自己的特殊属性，所以用`typeof`区分函数和其他对象。

3. **Undefined类型**

   1. 只有一个值`undefined`，使用var或let声明了但没初始化相当于赋了`undefined`值，默认未经初始化的变量都会取得 `undefined`值。
   2. 声明未初始化以及未声明，都会返回"undefined"，所以建议声明的同时初始化。
   3. `undefined`是一个假(false)值。

4. **Null类型**

   1. 只有一个值`null`，表示一个空对象指针。
   2. 用`null`来初始化将来要保存对象值的变量。
   3. `null`也是一个假值，由`undefined`派生而来。

5. **Boolean类型**

   1. 两个字面值：`true`和`false`
   2. 其他类型通过`Boolean()`函数转换为布尔值。

   ![转布尔值](src\转为布尔值.png)

6. **Number类型**

   1. 二进制字面量以`0b`开头，八进制以`0o`开头，16进制以`0x`开头，科学记数法`eg: 3.25e7` ;

   2. 浮点值内存是整数值的两倍，所以ECMAScript会尽量把值转换为整数，如定义`1.` `1.0` 都会被转换成整数`1`处理；

   3. 由于浮点数精度问题，**永远不要测试特定的浮点值**。

   4. `isFinite()`函数测试数值范围。

   5. 特殊值`NaN`（Not a number）

      1. `0/0` `-0/+0` ，0，0相除返回 `NaN`；`1/0`为`Infinity`，`1/-0`为`-Infinity`，分子非零返回无穷大；
      2. 任何`NaN`操作返回`NaN`；
      3. `NaN`不等于包括`NaN`在内的任何值；
      4. `isNaN()`函数接收任意数据类型判断是否“不是数值”，该函数会先尝试转换为数值；

   6. 数值转换

      `Number()`转型函数，将任何数据类型转为数值；

      `parseInt()`依据指定基数 [ 参数 **radix** 的值]，把字符串 [ 参数 **string** 的值] 解析成整数;

      `parseFloat()`把一个字符串解析成浮点数。

7. **String类型**

   1. 字符串可以使用双引号（"）、单引号（'）或反引号（`）标示，几种表示没有区别。
   2. 通过length属性获取字符串长度。 eg:`text.length`；
   3. ECMAScript的字符串的值一旦创建就不能变了，要修改必须先销毁原始的字符串。
   4. 通过`toString()`方法转为字符串。eg:`obj.toString()`；
   5. null和undefined没有`toString`方法，使用`String()`转型函数。eg:`String(value)`；
   6. 字符串插值 `${}`可以直接写在字符串里，表达式中可以调用函数和方法。
   7. 模板字面量使用反引号 (\` \`)引用，是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能。
   8. *模板字面量标签函数；
   9. *使用默认的 String.raw 标签函数获取原始的模板字面量内容。

8. **Symbol类型**

   1. 符号是原始值，且符号实例是唯一、不可变的，它的用户是确保对象属性使用唯一标识符。
   2. 使用`Symbol()`函数初始化一个符号。eg：`let sym = Symbol();`
   3. *使用`Symbol.for()`在全局符号注册表中创建并重用符号。
   4. 凡是可以使用字符串或数值作为属性的地方，都可以使用符号作为属性。
   5. \* **常用内置符号**以Symbol工厂函数字符串属性的形式存在。

9. **Object类型**

   1. 通过创建Object类型的实例来创建自己的对象，再给对象添加属性和方法：`let o = new Object()`
   2. Object是派生其他类的基类，，所有属性和方法在派生对象同时存在。
      - `constructor`：用于创建当前对象的函数；
      - `hasOwnProperty(propertyName)`：判断当前实例是否存在给定的属性。
      - `isPrototypeOf(object)`：判断当前对象是否是另一个对象的原型
      - `propertyIsEnumerable(propertyName)`：用于判断给定的属性是否可以使用
      - `toLocalString()`返回对象的字符串表示。（本地化执环境）
      - `toString()`返回对象的字符串表示。
      - `valueOf()`返回对象对应的字符串、数值或布尔表示。

#### 3.5 操作符

大部略过

1. 指数操作符 ** 	

   `Math.pow(3,2);与 3**2 一样`

2. 等于操作符`==`和全等操作符`===`的区别在于前者会先进行强制类型转换再确定操作数是否相等。后者不转换操作数。

3. 逗号操作符在同一条语句执行多个操作

   eg:`let num1 = 1,num2 = 2,num3 = 3`;

#### 3.6 语句

1. `for-in` 

   严格的迭代语句，用于枚举对象中的非符号键属性

   `for (property in expression) statement		`eg:

   ```javascript
   for(const propName in window){
   document.write(propName);
   }//显示了BOM对象window的全部属性
   ```

   ECMAScript对象的属性是无序的，因此`for-in`不保证返回对象属性的顺序。

2. `for-of`

   严格的迭代语句，遍历可迭代对象的元素，

   `for(property of expression) statement`

   ```javascript
   for(const el of [2,4,6,8]){
   document.write(el);
   }
   ```

   按照可迭代对象的next()方法顺序迭代元素，不支持迭代的变量将抛出错误。

3. 标签语句 `label:statement`

4. `switch`语句在比较每个条件值时会使用全等操作符，不会强制转换数据类型。

#### 3.7 函数

1. 基本用法

   ```js
   function functionName(arg0, arg1,...,argN) { 
    statements 
   }
   ```

2. 最佳实践：函数要么返回值，要么不返回值。只在某个条件下返回值的函数会带来麻烦，尤其是调试时。



## 第4章 变量、作用域与内存

#### 4.1 原始值与引用值

1. 原始值就是最简单的数据，Undefined、Null、Boolean、Number、String 和 Symbol。保存原始值的变量**按值**访问；

   引用值则是由多个值构成的对象。JavaScript不能直接访问内存，实际上操作的是对该对象的引用而非实际的对象本身。为此，保存引用值的变量是**按引用**访问的。

2. 原始值大小固定，因此保存在栈内存上。

   引用值是对象，存储在堆内存上。

3. 复制值

   原始值复制直接复制内存里的原始值；

   引用值赋给另一个变量，复制的是一个指针，和原变量指向同一个对象。

4. 传递参数

   *明确*：**ECMAScript中所有函数的参数都是按值传递的**

   如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。

   ***在按引用传递参数时，值在内存中的位置会被保存在一个局部变量，这意味着对本地变量的修改会反映到函数外部。（这在 ECMAScript 中是不可能的。）**  需在后续实践中深入理解

5. 确定类型

   `typeof`确定原始值的类型好用，但对于引用值null或对象，使用`instanceof`判断对象是否为给定引用类型的实例。（按照原型链判定）

#### 4.2 执行上下文与作用域

1. 每个上下文关联一个**变量对象**，上下文中的所有变量和函数都存在这个对象上。上下文在其代码执行完毕后被销毁。

2. **全局上下文**是最外层的上下文，在浏览器中是window对象。`var`定义的全局变量和函数都会成为window对象的属性和方法，`let`和`const`的顶级声明不会定义在全局上下文中，但在作用域链解析效果上是一样的。

3. 每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文。

4. 上下文中的代码在执行的时候，会创建变量对象的一个**作用域链**，代码正在执行的上下文的变量对象始终位于作用域链的最前端。

5. 函数参数被认为是当前上下文中的变量

6. 执行到`try/catch`语句中的`catch`块，会在作用域链前端添加一个变量对象。创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。

7.  ** `const`**声明的变量不能再被赋其他引用值，但对象键值不受影响。如果想整个对象不能被修改，使用`Object.freeze()`，再赋值会静默失败。

   `const obj = Object.freeze({});`

   应尽多的使用`const`声明。

8. 查找标识符的顺序沿着作用域链，最终可达全局上下文的变量对象。

#### 4.3 垃圾回收

1. **标记清理**

   1. 标记内存中所有变量
   2. 去除上下文中的变量以及被上下文变量引用的变量的标记。
   3. 现有标记的就是待删除的，进行一次**内存清理**，销毁带标记的值并回收内存。

2. 引用计数

3. **内存管理**

   - 出于安全考虑，分配给浏览器的内存一般比较少，应保持较小的内存占用量。

     优化内存：**解除引用**：将不再必要的数据设置为null

   - 通过const和let声明提升性能；

   - 避免意外声明全局变量导致内存泄漏；



## 第10章 函数

​	函数是Function类型的实例，所以是一个对象，函数名为对象指针。

​	四种定义函数的方式

```javascript
function sum(num1, num2){
 return num1+num2;
}//函数声明的方式
```

```js
let sum = function(num1, num2){
 return num1+num2;
}; //函数表达式
```

```js
let sum = (num1, num2)=>{
 return num1+num2;
}; //箭头函数
```

```js
let sum = new Function("num1","num2","return num1+num2"); //Function构造函数，不推荐
```

#### 10.1 箭头函数

1. 可以使用函数表达式的地方都可以使用箭头函数；
2. 只有一个参数的时候，不需要括号；
3. 箭头函数不能使用`arguments` `super` `new.target`，不能用作构造函数，也没有`prototype`属性；

#### 10.2 函数名

1. 使用不带括号的函数名会访问函数指针，而不会执行函数。
2. 函数名就是指向函数的指针，一个函数可以有多个名称。

#### 10.3 理解参数

1. ECMAScript函数的参数只是为了方便才写出来的，不是必须；
2. 命名参数和arguments在内存是分开的，不过会保持同步，修改`arguments[0]`会修改对应命名参数`num1`的值，注意，在严格模式下不会影响，`num1`的值不变。
3. 箭头函数不能使用`arguments`关键字访问参数，只能通过命名参数访问；

#### 10.4 没有重载

1. ECMAScript函数没有签名，故而没有重载

#### 10.5 默认参数值

1. 显式定义默认参数

```js
function makeKing(name = 'Henry') { 
 return `King ${name} VIII`;
} 
```

箭头函数也可以用

```js
let makeKing = (name = 'Henry') => `King ${name}`;
```

2. 参数也存在于自己的作用域中，它们不能引用函数体的作用域：

#### 10.6 参数扩展与收集

1. 扩展参数

   ```js
   console.log(getSum(...values, ...[5,6,7]));
   ```

2. 收集参数

   没明白

#### 10.7 函数声明与函数表达式

1. JavaScript 引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中生成函数定义，进行了**函数声明提升**。而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。

   其他时候没有区别。

#### 10.9 函数内部

1. **arguments对象**

   一个类数组对象，包含调用函数时传入的所有参数。

2. **this对象**

   在标准函数中，this 引用的是把函数当成方法调用的上下文对象；

   在箭头函数中，this引用的是定义箭头函数的上下文。

3. **caller属性**

   引用的是调用当前函数的函数（函数的代码），如果是在全局作用域中调用的则为 null。

4. **new.target属性**

   如果函数是正常调用的，则 new.target 的值是 undefined；如果是使用 new 关键字调用的，则 new.target 将引用被调用的

   构造函数。

#### 10.10 函数属性与方法

1. 每个函数都有两个属性：

   `length` ：命名参数的个数；

   `prototype` ：保存引用类型所有实例方法，`toString()` `valueof()`都保存在`prototype`上，进而由所有实例共享

2. 还有两个方法：

   `apply()`: 会设置调用函数时函数体内 this 对象的值。apply()方法接收两个参数：函数内 this 的值和一个参数数组。第二个参数可以是 Array 的实例，但也可以是 arguments 对象。

   ```js
   let obj={
       name:"Cicy"
   }
   function f(){
       return this.name;
   }
   console.log(f.apply(obj));
   ```

   **作用**：调用函数；改变this值；

   接收的参数数组可以是 Array 的实例，也可以是 arguments 对象。

   `call()`向函数传参时，必须将参数一个一个地列出来，其他没区别。

   （还有一个`bind()`方法）；

#### 10.12 递归

1. 通常一个函数通过名称调用自己；

#### 10.13 尾调用优化

#### 10.14 闭包

1. **闭包**指的是引用了另一个函数作用域变量的函数，通常在嵌套函数中实现的。
2. 实现闭包的本质很简单，就是在一个函数内部定义的函数会把其包含函数的活动对象添加到自己的作用域链中。

3. *闭包中的this对象

#### 10.15 立即调用的函数表达式

1. 立即调用的**匿名函数**又被称作**立即调用的函数表达式**

   ```js
   (function(){
   }) ();//用来模拟块级作用域，ES6之后不需要这样
   ```

   另一个用途为锁定参数值；

#### 10.16 私有变量

1. JavaScript没有私有成员的概念（对象的属性都是公有），有**私有变量**的概念。任何定义在函数或块中的变量，都可以认为是私有的，因为外部无法访问。

   私有变量包括**函数参数、局部变量，以及函数内部定义的其他函数**。

2. **特权方法**是能够访问函数私有变量（及私有函数）的公有方法。

3. *模块模式



## 第12章 BOM

#### 12.1 window对象

1. BOM的核心是window对象，表示浏览器的实例。

   两重身份：ECMAScript中的Global对象；浏览器窗口的JavaScript接口。

2. 网页中定义的所有对象、变量和函数都以 window 作为其 Global 对象，都可以访问其上定义的 parseInt()等全局方法。

3. window对象被复用为 ECMAScript 的 Global 对象，所以通过 var 声明的所有全局变量和函数都会变成 window 对象的属性和方法。如果使用 let 或 const 替代 var，则不会把变量添加给全局对象。

4. 窗口关系

   window.parent、window.top 和 window.self

   top对象指向最外层窗口，即浏览器窗口本身。

   parent对象指向当前窗口的父窗口。

   self和window是同一个对象

